<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark" />

    <link rel="stylesheet" type="text/css" href="../index.css">
    <link rel="stylesheet" type="text/css" href="./style guide.css">

    <title>UHS Software Engineering Club C++ Style Guide</title>
</head>

<body>

    <h1 class="header"><a href="../index.html">UHS Software Engineering Club C++ Style Guide</a></h1>

    <div class="table-of-contents" id="table-of-contents">

        <h2 class="section-header">Table of Contents</h2>
        <ul>
            <li /><a href="#overview">Overview</a>
            <li /><a href="#copyright">Copyright</a>
            <li /><a href="#c++-version">C++ Version</a>
            <li>
                <a href="#header-files">Header Files</a>
                <ul>
                    <li /><a href="#header-files-self-contained-headers">Self-contained Headers</a>
                    <li /><a href="#header-files-the-define-guard">The <code>#define</code> Guard</a>
                    <li /><a href="#header-files-include-what-you-use">Include What You Use</a>
                    <li /><a href="#header-files-forward-declarations">Forward Declarations</a>
                    <li /><a href="#header-files-inline-functions">Inline Functions</a>
                    <li /><a href="#header-files-names-and-order-of-includes">Names and Order of Includes</a>
                </ul>
            </li>
            <li>
                <a href="#scoping">Scoping</a>
                <ul>
                    <li><a href="#scoping-namespaces">Namespaces</a></li>
                </ul>
            </li>
        </ul>

        <button onclick="open_table_of_contents_on_new_tab()" id="open_table_of_contents_on_new_tab_button"
            title="Open Table of Contents on New Tab">Table of Contents</button>

        <script src="./style guide.js"></script>

    </div>

    <div class="body-content">

        <a id="overview" />
        <h2 class="section-header">Overview</h2>
        <ul>
            <li>
                This guide is intended to standardize one's coding style, in order to standardize the contribution to
                codebases of <a href="https://github.com/UHS-Software-Engineering-Club"><i>UHS Software Engineering
                        Club</i></a>.
            </li>

            <li>
                This guide is <b>NOT</b> a C++ tutorial: contributors to this guide will assume the reader is familiar
                with the language.
            </li>

            <li>
                The intent of this guide is to provide maximal guidance with reasonable restriction. As always, common
                sense and good taste should prevail. By this we specifically refer to the established conventions of the
                entire C++ community, not just one's personal preferences or those of one's team. Be skeptical about and
                reluctant to use clever or unusual constructs: the absence of a prohibition is not the same as a license
                to proceed. Use one's judgment, and if one is unsure, please <b>do NOT</b> hesitate to ask other
                contributors to get additional input.
            </li>

            <li>
                Last but not least, please keep in mind that every rule has exceptions.
            </li>

            <li>
                <b style="color: red;">NOTE: THIS STYLE GUIDE IS NOT YET COMPLETED. PLEASE COME BACK TO CHECK IT OUT
                    FREQUENTLY AS NEW INFORMATION WILL BE APPENDED REGULARLY.</b>
            </li>
        </ul>

        <a id="copyright" />
        <h2 class="section-header">Copyright</h2>
        <p>
            This guide is a variant of <a href="https://google.github.io/styleguide/cppguide.html"><i>Google C++ Style
                    Guide</i></a>. Latter is which licensed under Apache License 2.0, free for commercial use,
            modification, distribution, patent use, and private use.
        </p>
        <p>
            As contribution comes from different sources, we are not able to trace all contributors' work. By
            contributing to this style guide, one grants permission to <i>UHS Software Engineering Club</i> of
            commercial use,
            modification, distribution, patent use, and private use.
        </p>

        <a id="c++-version" />
        <h2 class="section-header">C++ Version</h2>
        <p>
            Despite <abbr title="LLVM/Clang">major compilers</abbr> only provide partial C++20 support, to reduce
            refactor complexity, code should still target C++20, i.e. should not use <abbr title="C++23">C++2b</abbr>
            features. The C++ version targeted by this guide will advance (aggressively) over time.
        </p>
        <p>
            Do <b>NOT</b> use <a
                href="https://google.github.io/styleguide/cppguide.html#Nonstandard_Extensions">non-standard
                extensions</a>.
        </p>
        <p>
            Consider portability to other environments before using features from C++14, C++17, and C++20 in your
            project.
        </p>

        <a id="header-files" />
        <h2 class="section-header">Header Files</h2>
        <p>
            In general, every <code>.cc</code> file should have an associated <code>.h</code> file. There are some
            common exceptions, such as unit tests and small <code>.cc</code> files containing just a <code>main()</code>
            function.
        </p>
        <p>
            Correct use of header files can make a huge difference to the readability, size and performance of one's
            code.
        </p>
        <p>
            The following rules will guide you through the various pitfalls of using header files.
        </p>

        <a id="header-files-self-contained-headers" />
        <h3 class="section-header">Self-contained Headers</h3>
        <p>
            Header files should be self-contained (compile on their own) and end in <code>.h</code>. Non-header files
            that are meant for inclusion should end in <code>.inc</code> and be used sparingly.
            <br>
            All header files should be self-contained. Users and refactoring tools should not have to adhere to special
            conditions to include the header. Specifically, a header should have <a
                href="#header-files-the-define-guard">header guards</a> and include all other headers it needs.
        </p>
        <p>
            When a header declares <code>inline</code> functions or templates that clients of the header will
            instantiate, the <code>inline</code> functions and templates must also have definitions in the header,
            either directly or in files it includes. Do not move these definitions to separately included header
            (<code>-inl.h</code>) files; this practice was common in the past, but is no longer allowed. When all
            instantiations of a template occur in one <code>.cc</code> file, either because they are <a
                href="https://en.cppreference.com/w/cpp/language/class_template#Explicit_instantiation">explicit</a> or
            because the definition is accessible to only the <code>.cc</code> file, the template definition can be kept
            in that file.
        </p>
        <p>
            There are rare cases where a file designed to be included is not self-contained. These are typically
            intended to be included at unusual locations, such as the middle of another file. They might not use <a
                href="#header-files-the-define-guard">header guards</a>, and might not include their prerequisites. Name
            such files with in <code>.inc</code> extension. Use sparingly, and prefer self-contained headers when
            possible.
        </p>

        <a id="header-files-the-define-guard" />
        <h3 class="section-header">The <code>#define</code> Guard</h3>
        <p>
            All header files should have <code>#define</code> guards to prevent multiple inclusion. The format of the
            symbol should be <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code>.
        </p>
        <p>
            To guarantee uniqueness, they should be based on the full path in a project's include tree. For example, the
            file <code>foo/include/foo/bar/baz_baz.h</code> in project <code>foo</code> should have the following guard:
        <pre>
                <code>
                    #ifndef FOO_BAR_BAZBAZ_H_
                    #define FOO_BAR_BAZBAZ_H_
                    ...
                    #endif // FOO_BAR_BAZBAZ_H_
                </code>
            </pre>
        </p>

        <a id="header-files-include-what-you-use" />
        <h3 class="section-header">Include What You Use</h3>
        <p>
            If a source or header file refers to a symbol defined elsewhere, the file should directly include a header
            file which properly intends to provide a declaration of definition of that symbol. It should not include
            header files for any other reason.
        </p>
        <p>
            Do not rely on transitive inclusions. This allows people to remove no-longer-needed <code>#include</code>
            statements from their headers without breaking clients. This also applies to related headers -
            <code>foo.cc</code> should include <code>bar.h</code> if it uses a symbol from it even if <code>foo.h</code>
            includes <code>bar.h</code>.
        </p>

        <a id="header-files-forward-declarations" />
        <h3 class="section-header">Forward Declarations</h3>
        <p>
            Avoid using forward declarations where possible. Instead, include the headers you need.
        </p>

        <h4>Definition:</h4>
        <p>
            A <q>forward declaration</q> is a declaration of an entity without an associated definition.
        <pre>
                    <code>
                        // In a C++ source file:
                        class B;
                        void FuncInB();
                        extern int variable_in_b;
                        ABSL_DECLARE_FLAG(flag_in_b);
                    </code>
                </pre>
        </p>

        <h4>Pros:</h4>
        <ul>
            <li />Forward declarations can save compile time, as <code>#include</code>s force the compiler to open more
            files
            and process more input.
            <li />Forward declarations can save on unnecessary recompilation. <code>#include</code>s can force your code
            to be
            recompiled more often, due to unrelated changes in the header.
        </ul>
        <br>

        <h4>Cons:</h4>
        <ul>
            <li />Forward declarations can hide a dependency, allowing user code to skip necessary recompilation when
            headers
            change.
            <li />A forward declaration as opposed to an <code>#include</code> statement makes it difficult for
            automatic
            tooling to discover the module defining the symbol.
            <li />A forward declaration may be broken by subsequent changes to the library. Forward declarations of
            functions
            and templates can prevent the header owners from making otherwise-compatible changes to their APIs, such as
            widening
            a parameter type, adding a template parameter with a default value, or migrating to a new namespace.
            <li />Forward declaring symbols from namespace <code>std::</code> yields undefined behavior.
            <li>
                It can be difficult to determine whether a forward declaration or a full <code>#include</code> is
                needed.
                Replacing an <code>#include</code> with a forward declaration can silently change the meaning of code:

                <pre>
                    <code>
                        // b.h
                        struct B {};
                        struct D : B {};

                        // good_user.cc:
                        #include "b.h"
                        void f(B*);
                        void f(void*):
                        void test(D *x) { f(x); } // Calls f(B*)
                    </code>
                </pre>

                If the <code>#include</code> was replaced with forward declarations for <code>B</code> and
                <code>D</code>, <code>test()</code> would call <code>f(void*)</code>.
            </li>
            <br>

            <li />Forward declaring multiple symbols from a header can be more verbose than simply
            <code>#include</code>ing the
            header.
            <li />Structuring code to enable forward declarations (e.g., using pointer members instead of object
            members) can make
            the code slower and more complex.
        </ul>

        <h4>Decision:</h4>
        <p>
            Try to avoid forward declarations of entities defined in another project.
        </p>

        <a id="header-files-inline-functions" />
        <h3 class="section-header">Inline Functions</h3>
        <p>
            Define functions <code>inline</code> only when they are small, say, 10 lines or fewer.
        </p>

        <h4>Definition:</h4>
        <p>
            You can declare functions in a way that allows the compiler to expand them inline rather than calling them
            through the usual function call mechanism.
        </p>

        <h4>Pros:</h4>
        <p>
            Inlining a function can generate more efficient object code, as long as the inlined function is small. Feel
            free
            to
            inline accessors and mutators, and other short, performance-critical functions.
        </p>

        <h4>Cons:</h4>
        <p>
            Overuse of inlining can actually make programs slower. Depending on a function's size, inlining it can cause
            the
            code
            size to increase or decrease. Inlining a very small accessor function will usually decrease code size while
            inling a
            very large function can dramatically increase code size. On modern processors smaller code usually runs
            faster
            due to
            better use of the instruction cache.
        </p>

        <b>Decision:</b>
        <p>
            A decent rule of thumb is to not inline a function if it is more than 10 lines long. Beware of destructors,
            which are
            often longer than they appear because of implicit member- and base-destructor calls!
        </p>
        <p>
            Another useful rule of thumb: it's typically not cost effective to inline functions with loops or switch
            statements
            (unless, in the common sense, the loop or switch statement is never executed).
        </p>
        <p>
            It is important to know that functions are not always inlined even if they are declared as such; for
            example,
            virtual and recursive functions are not normally inlined. Usually recursive functions should not be inline.
            The main
            reason for making a virtual function inline is to place its definition in the class, either for convenience
            or to
            document its behavior, e.g., for accessors and mutators.

            <a id="header-files-names-and-order-of-includes" />
        <h3 class="section-header">Names and Order of Includes</h3>
        <p>
            Include headers in the following order: Related header, C system headers, C++ standard library headers,
            other libraries' headers, your project's headers.
        </p>
        <p>
            All of a project's header files should be listed as descendants of the project's source directory without
            use of UNIX directory aliases <code>.</code> (the current directory) or <code>..</code> (the parent
            directory). For example, <code>awesome-project/include/awesome-project/base/logging.h</code> should be
            included as:
        <pre>
                <code>
                    #include "awesome-project/base/logging.h"
                </code>
            </pre>
        </p>

        <p>
            In <code>dir/foo.cc</code> or <code>dir/foo_test.cc</code>, whose main purpose is to implement or test the
            stuff in <code>dir2/foo2.h</code>, order your includes as follows:
            <nl>
                <li /><code>dir2/foo2.h</code>.
                <li />A blank line.
                <li />C system headers (more precisely: headers in angle brackets with the <code>.h</code> extension),
                e.g., <code>&lt;unistd.h&gt;</code>, <code>&lt;stdlib.h&gt;</code>
                <li />A blank line.
                <li />C++ standard library headers (without file extension), e.g., <code>&lt;algorithm&gt;</code>,
                <code>&lt;cstddef&gt;</code>.
                <li />A blank line.
                <li />Other libraries' <code>.h</code> files.
                <li />A blank line.
                <li>Your project's <code>.h</code> files.</li>
            </nl>
            <br>
            Separate each non-empty group with one blank line.
        </p>
        <p>

            With the preferred ordering, if the related header <code>dir2/foo2.h</code> omits any necessary includes,
            the
            build of <code>dir/foo.cc</code> or <code>dir/foo_test.cc</code> will break. Thus, this rule ensures that
            build breaks show up first for the people working on these files, not for innocent people in other packages.
        </p>
        <p>

            <code>dir/foo.cc</code> and <code>dir2/foo2.h</code> are usually in the same directory (e.g.,
            <code>base/basictypes_test.cc</code> and <code>base/basictypes.h</code>), but may sometimes be in different
            directories too.
        </p>
        <p>
            Note that the C headers such as <code>stddef.h</code> are essentially interchangeable with their C++
            counterparts (<code>cstddef</code>). Either style is acceptable, but prefer consistency with existing code.
            If it's a newly created project, prefer to use their C++ counterparts (<code>cstddef</code>).
        </p>
        <p>
            Within each section the includes should be ordered alphabetically. Note that older code might not conform to
            this rule and should be fixed when convenient.
        </p>
        <p>
            For example, the includes in <code>awesome-project/src/awesome-project/foo/fooserver.cc</code> might
            look like this:
            <pre>
                <code>
                    #include "awesome-project/internal/foo/fooserver.h"

                    #include <sys/types.h>
                    #include <unistd.h>

                    #include <string>
                    #include <vector>

                    #include "base/basictypes.h"
                    #include "awesome-project/internal/foo/bar.h"
                    #include "third_party/absl/flags/flag.h"
                </code>
            </pre>
        </p>

        <h4>Exception</h4>
        <p>
            Sometimes, system-specific code needs conditional includes. Such code can put conditional includes after
            other includes. Of course, keep one's system-specific code small and localized. Example:
            <pre>
                <code>
                    #include "foo/public/fooserver.h"

                    #include "base/port.h" // For LANG_CXX11.

                    #ifdef LANG_CXX11
                    #include <initializer_list>
                    #endif // LANG_CXX11
                </code>
            </pre>
        </p>

        <a id="scoping" />
        <h2 class="section-header">Scoping</h2>
    
        <a id="scoping-namespaces" />
        <h3 class="section-header">Namespaces</h3>
        <p>
            With few exceptions, place code in a namespace. Namespaces should have unique names based on the project
            name, and possibly its path. Do not use <code>using-directives</code> (e.g., <code>using namespace
            foo</code>). Do not use inline namespaces. For unnamed namespaces, see <a
            href="https://google.github.io/styleguide/cppguide.html#Internal_Linkage">Internal Linkage</a>.
        </p>
    </div>

</body>

</html>